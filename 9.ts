//#9 Контролируйте расширение типов

// Когда вы инициализируете переменную константой, и при этом не указываете тип
// TS определяет его сам. Это называется процессом расширения 

// Предположим вы пишите библиотеку для работы с векторами.
// У вас пояивился вот такой интерфейс и метод

interface Vector3{
    x: number;
    y: number;
    z: number;
}

const getComponent = (vector: Vector3, axis : 'x' | 'y' | 'z') =>{
    return vector[axis];
}

// Однако при использовании возникнет ошибка
let x1 = 'x';
let vec = {x: 10, y: 10, z: 10}
getComponent(vec, x1);
//Argument of type 'String' is not assignable to parameter of type '"x" | "y" | "z"'.
//Type 'String' is not assignable to type '"z"'.ts(2345)

// Тип x определен как string, но getComponent ожидает более специфичный тип для второго аргумента

// TS предоставляет несколько возможностей для контроля расширениеми.
// Одна из них - const 
const x2  = 'x';
let vec2 = {x: 10, y: 10, z: 10}
getComponent(vec2, x2); 
// x не может быть переназначен, TS пробует вывести более узкий тип,
// не влекущий ошибок в нижеследующих назначениях

// Но const допускает неоднозначность в случае с обьектами и массивами.

// Если вы знаете тип лучше чем TS, то существует три способа перенастроить его поведение.
// 1) Явная аннотация типа
const x3: {x: 1|3|5} = {x: 1}
const y2: {x: 1|3|5} = {x: 2} // так как тип {x: 1|3|5}
const z2: {x: 1|3|5} = {x: 3}
// 2) Обеспечить дополнительный контекст для модуля проверки
// 3) Утдверждение const 
const v1 = {
    x: 1,
    y: 2,
} // тип {x: number, y: number}

const v2 = {
    x: 1 as const,
    y: 2,
} // тип {x: 1, y: number}
 

const v3 = {
    x: 1,
    y: 2,
} as const // тип {x: 1, y: 2}
 
// Постарайтесь понять как именно TS выводит тип из константы посредством ее расширения
// Разберитесь с утдверждением уровней типов: const, аннотации типов, контекст и as const